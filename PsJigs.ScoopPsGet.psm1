# Fail loading module if scoop is not installed
Get-Command -Name scoop -ErrorAction Stop

$CheckVer =
    scoop which scoop |
    Split-Path -Parent |
    Join-Path -ChildPath 'checkver.ps1' -Resolve -ErrorAction Stop

$PsModuleBucket = 'C:\Users\iyersr\Downloads\work\ScoopPsModules\bucket'
#     # $PSScriptRoot |
#     # Split-Path -Parent |
#     # Join-Path -ChildPath 'bucket' -Resolve -ErrorAction Stop

# $ScoopPsModuleDir = (get-item (scoop prefix scoop)).parent.parent.Parent.GetDirectories('modules').FullName

function New-ScoopPsModuleManifest {
    [CmdletBinding()]
    param(
        # Name of module to install
        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, Position=0 )]
        [string]
        $Name,

        # Version of module to install
        [Parameter(ValueFromPipelineByPropertyName, Position=1 )]
        [version]
        $Version=$null,

        # Recreate manifest if it exists
        [switch]
        $Force
    )

    begin {}

    process {
        $ManifestPath = Join-Path -Path $PsModuleBucket -ChildPath "PsModule-$Name.json"
        if ( ( Test-Path $ManifestPath ) -and -not $Force ) {
            throw "Manifest already exists for $Name at $ManifestPath"
        }
        if ( $Version ) {
            $VersionWhere = "Version eq '$Version'"
        } else {
            $VersionWhere = 'IsLatestVersion eq true'
        }
        $UrlPrefix = "https://www.powershellgallery.com/api/v2"
        $ModuleInfoUrlFormat = "$UrlPrefix/Packages()?`$filter=Id eq '{0}' and {1}"
        $ModuleInfo = ( Invoke-RestMethod -Uri ( $ModuleInfoUrlFormat -f $Name, $VersionWhere ) ).properties
        if ( -not $ModuleInfo ) {
            throw "Powershell module $Name not found"
        }
        $Dependencies = $ModuleInfo.Dependencies -split ':[^:]+:\|*' | Where-Object {$_}
        $Dependencies
        $Dependencies |
            ForEach-Object { 
                try {
                    New-ScoopPsModuleManifest -Name $_
                }
                catch {
                    if ( -Not $_.Exception.Message.StartsWith('Manifest already exists for ') ) {
                        throw
                    }
                }
            }
        @{
            'version' = 'To be generated by checkver'
            'url' = 'to be generated by checkver'
            'hash' = 'to be generated by checkver'
            'description' = $ModuleInfo.Description
            'homepage' = "https://www.powershellgallery.com/packages/$($ModuleInfo.Id)"
            'license' =
                if ($ModuleInfo.LicenseUrl.null) {
                    'Unknown'
                } else {
                    @{
                        'url' = $ModuleInfo.LicenseUrl
                    }
                }
            'checkver' =
                @{
                    'url'     = $ModuleInfoUrlFormat -f $ModuleInfo.Id, 'IsLatestVersion eq true'
                    'regex'   = '(?i)<d:Version>(?<ver>[^<]+)<.d:Version>'
                    'replace' = '${ver}'
                }
            'autoupdate' =
                @{
                    'url'        = "$UrlPrefix/Package/$($ModuleInfo.Id)/`$version#/mod.nupkg"
                    'hash'       = @{
                        'url'   = $ModuleInfoUrlFormat -f $ModuleInfo.Id, 'Version eq ''$version'''
                        'regex' = '<d:PackageHash>$base64<.d:PackageHash>'
                    }
                }
            'depends' = $Dependencies -replace '^','PsModule-'
            'module' = @{
                'name' = $ModuleInfo.Id
            }
        } |
        ConvertTo-Json -Depth 5 |
        Set-Content -Path $ManifestPath -Encoding ascii -NoNewline
        
        & $CheckVer -Dir $PsModuleBucket -App "PsModule-$($ModuleInfo.Id)" -Update -Version $Version
    }

    end {}
}

function Update-ScoopPsModuleManifest{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end {}
}
function Remove-ScoopPsModuleManifest{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end {}
}
function Install-ScoopPsModule{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end {}
}
function Update-ScoopPsModule{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end {}
}
function UnInstall-ScoopPsModule{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end  {}
}
function Get-ScoopPsModule{
    [CmdletBinding()]
    param()
    begin {}
    process {}
    end {}
}
# Class InstalledScoopPsModules : System.Management.Automation.IValidateSetValuesGenerator {
#     [String[]] GetValidValues() {
#         return ( Get-ScoopPsModules )
#     }
# }

# function Invoke-ArgCompleterInstalledScoopPsModules {
#     param(
#         $CommandName,
#         $ParameterName,
#         $WordToComplete,
#         $CommandAst,
#         $FakeBoundParameters
#     )
    
#     Get-ScoopPsModules |
#     Where-Object { $_ -like "$WordToComplete"}
# }

# function Invoke-ValidateInstalledScoopPsModules {
#     param($v)
    
# }

# function Get-ScoopPsModules {
#     [CmdletBinding()]
#     param(
#        # Name of module
#        [Parameter(ValueFromPipelineByPropertyName, ValueFromPipeline, Position=0 )]
#        [SupportsWildcards()]
#        [ValidateScript({ $v=$_; Get-ScoopPsModules | Where-Object { $_ -like $v }  })]
#        [ArgumentCompleter({ param($c, $p, $w, $a, $f) Get-ScoopPsModules | Where-Object { $_ -like "$w*" }  })]
#        [string]
#        $Name='*'
#     )

#     process {
#         & scoop list '^PsModule-' 6>$null |
#         ForEach-Object {
#             $_.Name -replace '^PsModule-', ''
#         } |
#         Where-Object { $_ -like $Name }
#     }
# }

# function Get-ManifestPath {
#     [CmdletBinding()]
#     param(
#         # Name of module
#         [string]
#         $Name,

#         # Make sure it exists
#         [switch]
#         $Resolve
#     )
#     Join-Path -Path $Bucket -ChildPath "PsModule-$Name.json" -Resolve:$Resolve
# }

# function Install-ScoopPsModules{
#     [CmdletBinding()]
#     param (
#        # Name of module to install
#        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, Position=0 )]
#        [string]
#        $Name
#     )

#     begin {
#     }

#     process {
#         $ModuleInfo = Invoke-rest -Url "https://www.powershellgallery.com/api/v2/Packages()?`$filter=Id eq '$Name' and IsLatestVersion eq true"
#         if ( -not $ModuleInfo ) {
#             throw "Module $Name not found"
#         } else {

#         }
#         $VerifiedName =$ModuleInfo.Name
#         $ManifestPath = Get-ManifestPath -Name $Name
#         if ( -not ( Test-Path -Path $ManifestPath -PathType Leaf ) ) {
#             @{
#                 'version' = $ModuleInfo.properties.Version
#                 'description' = $ModuleInfo.properties.Description
#                 'homepage' = $ModuleInfo.properties.GalleryDetailsUrl
#                 'license' =
#                     if ($ModuleInfo.properties.LicenseUrl.null) {
#                         'Unknown'
#                     } else {
#                         @{
#                             'url' = $ModuleInfo.properties.LicenseUrl
#                         }
#                     }
#                 'autoupdate'
#                 'checkver'
#                 'depends'
#                 'extract_to'
#                 'url' = $ModuleInfo.content.src
#                 'hash' = 'generated'
#                 'url' = 'generated'
#                 'checkver' = @{
#                     're' = '([\d.]+)\s*\(current version'
#                 }
#                 'autoupdate' = @{
#                     'url' = "https://www.powershellgallery.com/api/v2/package/Az.KeyVault/`$version#$VerifiedName.nupkg"
#                 }
#                 'psmodule' = @{
#                     'name' = $VerifiedName
#                 }
#             } |
#             ConvertTo-Json -Depth 100 |
#             Set-Content -Path $ManifestPath -Encoding ascii -NoNewline
#         }
#         & $CheckVer -Dir $Bucket -App "PsModule-$VerifiedName" -Update
#         & scoop install $ManifestPath --no-update-scoop
#     }

#     end {
#     }
# }
# # function UnInstall-ScoopPsModules {
#     [CmdletBinding()]
#     param (
#        # Name of module to install
#        [Parameter(Mandatory, ValueFromPipelineByPropertyName, ValueFromPipeline, Position=0 )]
#        [SupportsWildcards()]
#        [ValidateSet([InstalledScoopPsModules])]
#        [string]
#        $Name
#     )

#     begin {
#     }

#     process {
#         $ManifestPath = Get-ManifestPath -Name $Name -Resolve -ErrorAction Stop
#         $ScoopApp = Split-Path -Path $ManifestPath -LeafBase
#         & scoop uninstall $ScoopApp
#         Remove-Item -Path $ManifestPath
#     }

#     end {
#     }
# }

# Fail loading module if scoop is not installed
# Get-Command -Name Scoop1 -ErrorAction Stop

# Update-ScoopPsModules